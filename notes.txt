Commands:

	GET /
		list top-level objects

	POST /_new/bucket
		create bucket with attributes

	GET /_providers
		list providers

	POST /_providers/_new/provider
		create new provider with info

	GET /_providers/provider
		show provider information (requires token)

	POST /_providers/provider
		set provider information (requires/token)

	GET /bucket
		list bucket contents

	GET /bucket?query=xxx
		query bucket contents

	DELETE /bucket
		delete bucket (must be empty)

	POST /bucket/_new/object
		create object with attributes

	GET /bucket/object
		get body/attr* list

	GET /bucket/object/body
		get object body

	PUT /bucket/object/body
		put object body

	POST /bucket/object op=push
		trigger re-replication

	POST /bucket/object op=pull depot=xxx
		trigger reverse replication

	POST /bucket/object op-check depot=xxx
		check availability

	DELETE /bucket/object
		delete object

	GET /bucket/object/attrs
		get all attributes

	POST /bucket/object/attrs
		set multiple attributes

	GET /bucket/object/attr_X
		get attribute X

	PUT /bucket/object/attr_X
		set attribute X

	DELETE /bucket/object/attr_X
		delete attribute X

Formats:

	JSON top-level list
	[
		{
			"type": "bucket_factory",
			"path": ".../_new"
		},
		{
			"type": "provider_list",
			"path": ".../_providers"
		},
		{
			"type": "bucket",
			"name": "bucketA",
			"path": ".../bucketA"
		},
		{
			"type": "bucket",
			"name": "bucketB",
			"path": ".../bucketB"
		}
	]

	JSON provider list
	[
		{
			"name": "my primary",
			"type": "cf",
			"host": "swift.usersys.redhat.com",
			"port": 8080,
			"username": "my_cf_username",
			"password": "my_cf_password"
		},
		{
			"name": "my secondary",
			"type": "s3",
			"host": "s3.amazonaws.com",
			"port": 80,
			"username": "my_aws_key",
			"password": "my_aws_secret"
		}
	}

	JSON bucket-level list
	[
		{
			"type": "object_factory",
			"path": ".../bucket/_new"
		},
		{
			"type": "object",
			"name": "objectC",
			"path": ".../bucketA/objectC"
		},
		{
			"type": "object",
			"name": "objectD",
			"path": ".../bucketA/objectD"
		}
	]

	JSON object-level list
	[
		{
			"type": "body",
			"path": ".../bucketA/objectC/body"
		},
		{
			"type": "multi_attributes",
			"path": ".../bucketA/objectC/attrs"
		},
		{
			"type": "single_attribute",
			"name": "abc",
			"path": ".../bucketA/objectC/attr_abc"
		}
		{
			"type": "single_attribute",
			"name": "xyz",
			"path": ".../bucketA/objectC/attr_xyz"
		}
	]


To Do - priority (1 highest) work (5 largest) desc:
	1 1 policy inheritance
	1 2 delete metadata as well as data
	1 3 re-replicate on policy change (single object)
	2 2 manual re-replication trigger
	2 1 re-replicate on *any* tag change
	2 3 replication-complete API
	2 5 basic cred-management API
	2 3 content types
	--- done
	2 1 start own MongoDB
	2 2 reverse-replication API
	2 4 link-following syntax
	2 5 reconcile dispatch with commands/format above
	3 5 fully modular FS/S3/CF driver structure
	3 5 VMWare back end
	3 5 EBS back end
	3 5 RHEV back end (dependency on Ayal)
	    * Mark McLoughlin / Eoghan Glynn / rhevm-api
	3 5 start own Hail
	3 5 fully dynamic config
	3 3 fix string handling (eliminate strtok)
	3 4 re-replicate on policy change (default)
	3 4 writes proxied upstream
	4 1 direct-copy API (PUT with special header?)
	4 2 use MongoDB C driver now that it's supported
	4 3 chunked encoding
	4 3 statistics/usage API
	4 3 enhanced query syntax (limits)
	4 4 optimize re-replication (check current locs)
	4 5 dcloud-obj back end
	4 5 immediate inline replication
	4 5 generate MongoDB queries from ours
	4 5 auth
	5 2 deletes proxied upstream
	5 3 cache control (TTL?)
	5 5 replicated DB
	partial-object reads
	partial-object writes?

