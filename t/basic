#!/bin/sh
# Test basic functionality.

. "${srcdir=.}/init.sh"; path_prepend_ ..

mkdir FS mongod iwhd || framework_failure_ mkdir failed

# FIXME: start this only if there's not a working one already running, or
# probably better, start this one unconditionally and make iwhd use it.
mongod --pidfilepath mongod/pid --dbpath mongod > mongod.log 2>&1 &
mongo_pid=$!
cleanup_() { kill $mongo_pid; }

# Wait for up to 3 seconds for mongod to begin listening.
wait_for .1 30 'mongo < /dev/null' \
  || framework_failure_ mongod failed to start

port=9091
cat <<EOF > root.xml || framework_failure_
<api service="image_warehouse" version="$VERSION">
	<link rel="bucket_factory" href="http://localhost:$port/_new"/>
	<link rel="provider_list" href="http://localhost:$port/_providers"/>
	<link rel="bucket" href="http://localhost:$port/b1"/>
</api>
EOF

cat <<EOF > root.json || framework_failure_
{
	"service": "image_warehouse",
	"version": "$VERSION",
	[
		{
			"rel": "bucket_factory",
			"link": "http://localhost:$port/_new"
		},
		{
			"rel": "provider_list",
			"link": "http://localhost:$port/_providers"
		},
		{
			"rel": "bucket",
			"link": "http://localhost:$port/b1"
		}
	]
}
EOF

emit_provider()
{
  local xml_or_json=$1
  case $# in 7);; *) echo "emit_provider: wrong # args" 1>&2; exit 1;; esac
  case $xml_or_json in xml|json);;
    *) echo "invalid xml_or_json $xml_or_json" 1>&2; exit 1;; esac

  if test $xml_or_json = xml; then
    printf \
'<providers>
\t<provider name="%s">
\t\t<type>%s</type>
\t\t<host>%s</host>
\t\t<port>%s</port>
\t\t<username>%s</username>
\t\t<password>%s</password>
\t</provider>
</providers>
' $2 $3 $4 $5 $6 $7
  else
    printf \
'[
\t{
\t\t"name": "%s",
\t\t"type": "%s",
\t\t"host": "%s",
\t\t"port": %s,
\t\t"username": "%s",
\t\t"password": "%s"
\t}
]
' $2 $3 $4 $5 $6 $7
  fi
}

emit_bucket_list()
{
  local xml_or_json=$1
  case $xml_or_json in xml|json);;
    *) echo "invalid xml_or_json $xml_or_json" 1>&2; exit 1;; esac
  shift

  local i b k
  if test $xml_or_json = xml; then
    printf '<objects>\n'
    for i in "$@"; do
      b=$(echo "$i"|sed 's/:.*//')
      k=$(echo "$i"|sed 's/.*://')
      printf \
'\t<object>
\t\t<bucket>%s</bucket>
\t\t<key>%s</key>
\t</object>
' $b $k
    done
    printf '</objects>\n'
  else
    printf '[\n'
    for i in "$@"; do
      b=$(echo "$i"|sed 's/:.*//')
      k=$(echo "$i"|sed 's/.*://')
      printf \
'\t{
\t\t"bucket": "%s",
\t\t"key": "%s"
\t}
' $b $k
    done
    printf ']\n'
  fi

}

printf '[{"path": "FS", "type": "fs", "name": "primary"}]\n' \
  > iwhd.cfg || fail=1

iwhd -v -p $port -c iwhd.cfg &
iwhd_pid=$!
cleanup_() { kill $mongo_pid $iwhd_pid; }

# Wait for up to 3 seconds for iwhd to begin listening on $port.
wait_for .1 30 "curl -s http://localhost:$port" \
  || { echo iwhd failed to listen; Exit 1; }


# Create an empty bucket.
curl -X PUT http://localhost:$port/b1 || fail=1
test -d FS/b1 || fail=1

# Try to create a duplicate bucket.
curl -f -X PUT http://localhost:$port/b1 2> dup_bucket.err
grep ' 500$' dup_bucket.err || fail=1

# PUT to root; should fail
curl -f -X PUT http://localhost:$port 2> root_put.err
grep ' 404$' root_put.err || fail=1

# Create a file in that bucket.
echo foo | curl -T - http://localhost:$port/b1/f1 || fail=1
# Test presence in the FS.
test -f FS/b1/f1 || fail=1
test "$(cat FS/b1/f1)" = foo || fail=1
# Test through the API as well.
curl http://localhost:$port/b1/f1 > f1copy
test "$(cat f1copy)" = foo || fail=1


# Get root; default, then Accept: XML & JSON:
curl http://localhost:$port > root || fail=1
compare root root.xml || fail=1

curl -H 'Accept: */xml' http://localhost:$port > root || fail=1
compare root root.xml || fail=1

curl -H 'Accept: */json' http://localhost:$port > root || fail=1
compare root root.json || fail=1

# Delete an object.
curl -X DELETE http://localhost:$port/b1/f1 || fail=1
# Ensure that it's gone from the file system.
test -f FS/b1/f1 && fail=1
# Ensure that it's gone in the API as well.
curl -f http://localhost:$port/b1/f1 > /dev/null 2> del_object.err
grep ' 404$' del_object.err || fail=1

# Try to delete a nonexistent object.
curl -f -X DELETE http://localhost:$port/b1/no-such-obj 2> del_nosuch.err
grep ' 404$' del_nosuch.err || fail=1


# ################## Providers

p_name=primary
host='(null)'

# Verify that default providers information is as expected.
curl http://localhost:$port/_providers > p || fail=1
emit_provider xml "$p_name" fs "$host" 0 '' '' > p.exp || fail=1
compare p.exp p || fail=1

for i in xml json; do

  curl_H() { curl -H "Accept: */$i" "$@"; }

  # Change username and password; ensure that is reflected in providers output.
  curl_H -d provider="$p_name" -d username=u -d password=p \
    http://localhost:$port/_providers || fail=1
  curl_H http://localhost:$port/_providers > p || fail=1
  emit_provider $i "$p_name" fs "$host" 0 u p > p.xml || fail=1
  compare p.xml p || fail=1

  # Attempt to modify some other attribute; should fail (but curl won't)
  curl_H -d provider="$p_name" -d other_attr=foo \
    http://localhost:$port/_providers || fail=1

  # Attempt to modify nonexistent provider; should fail
  curl_H -d provider=no_such -d username=v -d password=q \
    http://localhost:$port/_providers || fail=1

  # Try to change just one of username and password, not specifying the other.
  # Ensure that the attempt fails.
  curl_H -d provider="$p_name" -d username=u \
    http://localhost:$port/_providers || fail=1
  curl_H http://localhost:$port/_providers > p || fail=1
  emit_provider $i "$p_name" fs "$host" 0 u p > p.exp || fail=1
  compare p.exp p || fail=1

  curl_H -d provider="$p_name" -d password=p \
    http://localhost:$port/_providers || fail=1
  curl_H http://localhost:$port/_providers > p || fail=1
  emit_provider $i "$p_name" fs "$host" 0 u p > p.exp || fail=1
  compare p.exp p || fail=1

  # Try to change both username and password.  Now, it must succeed.
  curl_H -d provider="$p_name" -d username=v -d password=q \
    http://localhost:$port/_providers || fail=1
  curl_H http://localhost:$port/_providers > p || fail=1
  emit_provider $i "$p_name" fs "$host" 0 v q > p.exp || fail=1
  compare p.exp p || fail=1

  # List an empty bucket.
  curl_H http://localhost:$port/b1 > b || fail=1
  emit_bucket_list $i > b.exp || fail=1
  compare b.exp b || fail=1

  # Add an object, list non-empty bucket.
  echo bar | curl -T - http://localhost:$port/b1/f2 || fail=1

  # Ensure that new name appears in the listing.
  curl_H http://localhost:$port/b1 > b || fail=1
  emit_bucket_list $i b1:f2 > b.exp || fail=1
  compare b.exp b || fail=1

  # Remove b1/f2, to restore state for next iteration of this loop.
  curl -X DELETE http://localhost:$port/b1/f2 || fail=1

done


# Add a single attribute to an object using the PUT method.
bucket=http://localhost:$port/b1
printf nothing | curl -T - $bucket/f3 || fail=1
printf blue | curl -T - $bucket/f3/color || fail=1
test "$(curl $bucket/f3/color)" = blue || fail=1

# Add multiple attributes to an object using the POST method.
# NB use a file which doesn't yet exist (yes, this should work too)
curl -d key=f4 -d shape=round -d size=big $bucket || fail=1
test "$(curl $bucket/f4/shape)" = round || fail=1
test "$(curl $bucket/f4/size)" = big || fail=1

# Ensure that an attempt to add each reserved attribute fails.
# FIXME: keep this list in sync with the one in rest.c:
# grep '^static.*reserved_attr' rest.c
for attr in bucket key date etag loc; do
  printf whatever | curl -f -T - $bucket/f5/$attr 2> bad_attr.err
  grep ' 400$' bad_attr.err || fail=1
done

# TBD: add attribute-delete tests when that functionality is implemented

# TBD: add white-box tests for attributes in mongo

Exit $fail
