#!/bin/sh
# Test basic functionality.

# TEST-FILE USAGE
#	obj_test	object put/get/delete
#	list_test	bucket listing
#	attr_put	attribute PUT, headless operation
#	attr_post	attribute POST
#	rsvd_attr	reserved attr
#	role_test	X-redhat-role
#	trunc_test	truncation

. "${srcdir=.}/init.sh"; path_prepend_ ..

mkdir FS mongod iwhd || framework_failure_ mkdir failed

m_port=$(expr $mongo_base_port + 0)

mongod --port $m_port --pidfilepath mongod/pid --dbpath mongod > mongod.log 2>&1 &
mongo_pid=$!
cleanup_() { kill -9 $mongo_pid; }

# Wait for up to 3 seconds for mongod to begin listening.
wait_for .1 30 'mongo localhost:$m_port < /dev/null' \
  || framework_failure_ mongod failed to start

port=9091
bucket=http://localhost:$port/b1

cat <<EOF > root.xml || framework_failure_
<api service="image_warehouse" version="$VERSION">
	<link rel="bucket_factory" href="http://localhost:$port/_new"/>
	<link rel="provider_list" href="http://localhost:$port/_providers"/>
	<link rel="bucket" href="$bucket"/>
</api>
EOF

cat <<EOF > root.json || framework_failure_
{
	"service": "image_warehouse",
	"version": "$VERSION",
	[
		{
			"rel": "bucket_factory",
			"link": "http://localhost:$port/_new"
		},
		{
			"rel": "provider_list",
			"link": "http://localhost:$port/_providers"
		},
		{
			"rel": "bucket",
			"link": "$bucket"
		}
	]
}
EOF

emit_provider()
{
  local xml_or_json=$1
  shift 1
  case $xml_or_json in xml|json);;
    *) echo "invalid xml_or_json $xml_or_json" 1>&2; exit 1;; esac
  case $# in 6);; *) echo "emit_provider: wrong # args" 1>&2; exit 1;; esac

  if test $xml_or_json = xml; then
    printf \
'<providers>
\t<provider name="%s">
\t\t<type>%s</type>
\t\t<host>%s</host>
\t\t<port>%s</port>
\t\t<username>%s</username>
\t\t<password>%s</password>
\t</provider>
</providers>
' "$@"
  else
    printf \
'[
\t{
\t\t"name": "%s",
\t\t"type": "%s",
\t\t"host": "%s",
\t\t"port": %s,
\t\t"username": "%s",
\t\t"password": "%s"
\t}
]
' "$@"
  fi
}

emit_bucket_list()
{
  local xml_or_json=$1
  case $xml_or_json in xml|json);;
    *) echo "invalid xml_or_json $xml_or_json" 1>&2; exit 1;; esac
  shift

  local i b k
  if test $xml_or_json = xml; then
    printf '<objects>\n'
    for i in "$@"; do
      b=$(echo "$i"|sed 's/:.*//')
      k=$(echo "$i"|sed 's/.*://')
      printf \
'\t<object>
\t\t<bucket>%s</bucket>
\t\t<key>%s</key>
\t</object>
' $b $k
    done
    printf '</objects>\n'
  else
    printf '[\n'
    for i in "$@"; do
      b=$(echo "$i"|sed 's/:.*//')
      k=$(echo "$i"|sed 's/.*://')
      printf \
'\t{
\t\t"bucket": "%s",
\t\t"key": "%s"
\t}
' $b $k
    done
    printf ']\n'
  fi

}

printf '[{"path": "FS", "type": "fs", "name": "primary"}]\n' \
  > iwhd.cfg || fail=1

iwhd -v -p $port -c iwhd.cfg -d localhost:$m_port &
iwhd_pid=$!
cleanup_() { kill -9 $mongo_pid; kill $iwhd_pid; }

# Wait for up to 3 seconds for iwhd to begin listening on $port.
wait_for .1 30 "curl -s http://localhost:$port" \
  || { echo iwhd failed to listen; Exit 1; }

# Create an empty bucket.
curl -X PUT $bucket || fail=1
test -d FS/b1 || fail=1

# Try to create a duplicate bucket.
curl -f -X PUT $bucket 2> dup_bucket.err
grep ' 500$' dup_bucket.err || fail=1

# PUT to root; should fail
curl -f -X PUT http://localhost:$port 2> root_put.err
grep ' 404$' root_put.err || fail=1

# Create a file in that bucket.
echo foo | curl -T - $bucket/obj_test || fail=1
# Test presence in the FS.
test -f FS/b1/obj_test || fail=1
test "$(cat FS/b1/obj_test)" = foo || fail=1
# Test through the API as well.
curl $bucket/obj_test > f1copy
test "$(cat f1copy)" = foo || fail=1


# Get root; default, then Accept: XML & JSON:
curl http://localhost:$port > root || fail=1
compare root root.xml || fail=1

curl -H 'Accept: */xml' http://localhost:$port > root || fail=1
compare root root.xml || fail=1

curl -H 'Accept: */json' http://localhost:$port > root || fail=1
compare root root.json || fail=1

# Delete an object.
curl -X DELETE $bucket/obj_test || fail=1
# Ensure that it's gone from the file system.
test -f FS/b1/obj_test && fail=1
# Ensure that it's gone in the API as well.
curl -f $bucket/obj_test > /dev/null 2> del_object.err
grep ' 404$' del_object.err || fail=1

# Try to delete a nonexistent object.
curl -f -X DELETE $bucket/no-such-obj 2> del_nosuch.err
grep ' 404$' del_nosuch.err || fail=1

# Make sure the X-redhat-role header causes failure on a master iwhd.
echo hello | curl -f -T - -H "X-redhat-role: master" $bucket/role_test \
	2> role.err
grep ' 403$' role.err || fail=1

# ################## Providers

p_name=primary

# Verify that default providers information is as expected.
curl http://localhost:$port/_providers > p || fail=1
emit_provider xml "$p_name" fs '' 0 '' '' > p.exp || fail=1
compare p.exp p || fail=1

for i in xml json; do

  curl_H() { curl -H "Accept: */$i" "$@"; }

  # Change username and password; ensure that is reflected in providers output.
  curl_H -d provider="$p_name" -d username=u -d password=p \
    http://localhost:$port/_providers || fail=1
  curl_H http://localhost:$port/_providers > p || fail=1
  emit_provider $i "$p_name" fs '' 0 u p > p.xml || fail=1
  compare p.xml p || fail=1

  # Attempt to modify some other attribute; should fail (but curl won't)
  curl_H -d provider="$p_name" -d other_attr=foo \
    http://localhost:$port/_providers || fail=1

  # Attempt to modify nonexistent provider; should fail
  curl_H -d provider=no_such -d username=v -d password=q \
    http://localhost:$port/_providers || fail=1

  # Try to change just one of username and password, not specifying the other.
  # Ensure that the attempt fails.
  curl_H -d provider="$p_name" -d username=u \
    http://localhost:$port/_providers || fail=1
  curl_H http://localhost:$port/_providers > p || fail=1
  emit_provider $i "$p_name" fs '' 0 u p > p.exp || fail=1
  compare p.exp p || fail=1

  curl_H -d provider="$p_name" -d password=p \
    http://localhost:$port/_providers || fail=1
  curl_H http://localhost:$port/_providers > p || fail=1
  emit_provider $i "$p_name" fs '' 0 u p > p.exp || fail=1
  compare p.exp p || fail=1

  # Try to change both username and password.  Now, it must succeed.
  curl_H -d provider="$p_name" -d username=v -d password=q \
    http://localhost:$port/_providers || fail=1
  curl_H http://localhost:$port/_providers > p || fail=1
  emit_provider $i "$p_name" fs '' 0 v q > p.exp || fail=1
  compare p.exp p || fail=1

  # List an empty bucket.
  curl_H $bucket > b || fail=1
  emit_bucket_list $i > b.exp || fail=1
  compare b.exp b || fail=1

  # Add an object, list non-empty bucket.
  echo bar | curl -T - $bucket/list_test || fail=1

  # Ensure that new name appears in the listing.
  curl_H $bucket > b || fail=1
  emit_bucket_list $i b1:list_test > b.exp || fail=1
  compare b.exp b || fail=1

  # Remove b1/list_test, to restore state for next iteration of this loop.
  curl -X DELETE $bucket/list_test || fail=1

done


# Add a single attribute to an object using the PUT method.
bucket=$bucket
printf nothing | curl -T - $bucket/attr_put || fail=1
printf blue | curl -T - $bucket/attr_put/color || fail=1
test "$(curl $bucket/attr_put/color)" = blue || fail=1

# Add multiple attributes to an object using the POST method.
# NB use a file which doesn't yet exist (yes, this should work too)
curl -d key=attr_post -d shape=round -d size=big $bucket || fail=1
test "$(curl $bucket/attr_post/shape)" = round || fail=1
test "$(curl $bucket/attr_post/size)" = big || fail=1

# Ensure that an attempt to add each reserved attribute fails.
# FIXME: keep this list in sync with the one in rest.c:
# grep '^static.*reserved_attr' rest.c
for attr in bucket key date etag loc; do
  printf whatever | curl -f -T - $bucket/rsvd_attr/$attr 2> bad_attr.err
  grep ' 400$' bad_attr.err || fail=1
done

# Make sure PUTting a file truncates.
echo hello | curl -f -T - $bucket/trunc_test || fail=1
echo bye | curl -f -T - $bucket/trunc_test || fail=1
cat FS/b1/trunc_test
test "$(cat FS/b1/trunc_test)" = bye || fail=1

# Test "headless" operation (no access to metadata DB).
kill -9 $mongo_pid
cleanup_() { kill $iwhd_pid; }
curl $bucket/attr_put > f3copy
test "$(cat f3copy)" = "nothing" || fail=1

# TBD: add attribute-delete tests when that functionality is implemented

# TBD: add white-box tests for attributes in mongo

Exit $fail
