# This file is sourced by init.sh, *before* its initialization.

# This goes hand in hand with the "exec 9>&2;" in Makefile.am's
# TESTS_ENVIRONMENT definition.
stderr_fileno_=9

# Always use curl's -q option, so that a user's .rc settings
# cannot perturb these tests.
# Also add -s and -S to get rid of silly progress bars etc.
curl() { env curl -q -s -S "$@"; }

# In order to run tests independently (i.e., in parallel), each script
# must run mongod on a different port.  Use an initialization like this
# in each script, where DDD is chosen to be larger than in any other script.
#   m_port=$(expr $mongo_base_port + DDD)
# And then start mongod on that port and specify iwhd's DB host
# using --db=localhost:$m_port.
# Avoid the built-in and auto-start defaults (27017 and 27018 respectively)
mongo_base_port=27019

wait_for()
{
  local sleep_seconds=$1
  local max_n_sleeps=$2
  local cmd=$3
  case $max_n_sleeps in
    [0-9]*);; *) echo invalid max_n_sleeps $max_n_sleeps 1>&2; exit 1;;
  esac
  case $sleep_seconds in
    [0-9]*|.[0-9]*);; *) echo invalid sleep interval $sleep_seconds 1>&2; exit 1;;
  esac
  local i=0
  while :; do
    eval "$cmd" && { echo "cmd took $i x ${sleep_seconds}s: '$cmd'"; return 0; }
    sleep $sleep_seconds
    i=$(expr $i + 1)
    test $i = $max_n_sleeps \
      && { warn_ "EXPIRED: $i x ${sleep_seconds}s: '$cmd'"; return 1; }
  done
}

emit_provider()
{
  local xml_or_json=$1
  shift 1
  case $xml_or_json in xml|json);;
    *) echo "invalid xml_or_json $xml_or_json" 1>&2; exit 1;; esac
  case $# in 6);; *) echo "emit_provider: wrong # args" 1>&2; exit 1;; esac

  if test $xml_or_json = xml; then
    printf \
'<providers>
\t<provider name="%s">
\t\t<type>%s</type>
\t\t<host>%s</host>
\t\t<port>%s</port>
\t\t<username>%s</username>
\t\t<password>%s</password>
\t</provider>
</providers>
' "$@"
  else
    printf \
'[
\t{
\t\t"name": "%s",
\t\t"type": "%s",
\t\t"host": "%s",
\t\t"port": %s,
\t\t"username": "%s",
\t\t"password": "%s"
\t}
]
' "$@"
  fi
}

emit_bucket_list()
{
  local xml_or_json=$1
  case $xml_or_json in xml|json);;
    *) echo "invalid xml_or_json $xml_or_json" 1>&2; exit 1;; esac
  shift

  local i b k
  if test $xml_or_json = xml; then
    printf '<objects>\n'
    for i in "$@"; do
      b=$(echo "$i"|sed 's/:.*//')
      k=$(echo "$i"|sed 's/.*://')
      printf \
'\t<object>
\t\t<bucket>%s</bucket>
\t\t<key>%s</key>
\t</object>
' $b $k
    done
    printf '</objects>\n'
  else
    printf '[\n'
    for i in "$@"; do
      b=$(echo "$i"|sed 's/:.*//')
      k=$(echo "$i"|sed 's/.*://')
      printf \
'\t{
\t\t"bucket": "%s",
\t\t"key": "%s"
\t}
' $b $k
    done
    printf ']\n'
  fi
}
